哈希表也叫散列表，对于一个数组{5,4,3,9,7,6,8,1,2},存储的时候建立一个数组，将要存储的数据存入和他一样的下标的位置。
哈希表的底层是使用了数组进行存储
Hash，一般翻译做“散列”，也有直接音译为“哈希”的，就是把任意长度的输入，通过散列算法，变换成固定长度的输出，该输出就是散列值。
简单的说就是一种将任意长度的消息压缩到某一固定长度的消息摘要的函数。
        
            如果要存储比如17岁1人，18岁2人等等，  将17，1存储在下标为17的位置，将18，2存在18中。 
            在表中通过       存储位置=fun{关键字}得到存储位置  比如传入关键字年龄17，得到存储位置
            这个fun就是散列函数，通过将关键字和存储的数据比较得到存储位置的查找方法
            
            散列函数的设计标准:1.计算简单  2.分布均匀(计算好的数据均匀分布)
            散列函数的几种设计方式:
            1.直接定址法:在一个数组中，将要存储的数据的关键字作为它在数组中的下标，比如存储1岁多少人，2岁多少人，直接将1岁多少人存在下标为1的位置，2岁存在下标为2的位置
                                                                这种方法非常不方便，因为如果要存储   张三 15311111111 这样一条数据，手机号就是关键字，要求的数组就很大，下标为手机号不方便存取
            
            2.数字分析法:例如要存储    张三 15359121111 对电话号码进行分析，前七位一般都是差不多的，只有后四位不同，将后四位1111作为数组下标进行存储
                                                                下标同样有点大，数组长度也很长
                                                                
            3.平方取中法:将关键字平方，取平方后的数的中间的数作为下标进行存储。例如13，15.平方后为169 225，取中间的数6，2作为下标进行存储
                                                                但是平方取中法可能另一个数平方取中后和已经存储了的数据的下标相同。例如18 的平方为324，取中后为2，与此时2中存储的15相冲突，此时就需要解决散列冲突
                                                                
            4.取余法:将关键字除以某一个数，取他的余数作为下标进行存储。例如13 15，除以10  (13%10=3 15%10=5)，取余，那么存储的下标就为3 5
   
            5.随机数法:存储地址=random(); 存储地址为随机数，想放哪儿放哪儿。

散列冲突的解决:  
                    解决此类存储地址冲突的问题有两种方式:1.开放地址法  例如12 22进行取余存储，12先存放到下标2的空间，22要存放的话会覆盖掉12，为了不让22覆盖12的数据
                                                                                                             在后面重新找个地址来存放22的数据，这就是开放地址法
                                                                                                     开放地址法分为:a.线性探测法  在紧跟着的位置存放冲突的数据  例如22存储到下标为3的空间，如果3的位置有数据了，就挨个向后找，直到这个下标空间没存数据
                                                                                                                                               这样会造成数据聚集在一堆，而且有些下标存储的并不是取余的数据
                                                                                                                                               
                                            b.二次探测法:同样的，例如12 22，先存入12，再存22，发生冲突，此时将22要存的位置的下标2第一次加上1的平方，如果这个位置没有数据就存放数据
                                                                                                                                          如果已经有数据在这个位置，就加上2的平方，判断有无数据，有的话加3的平方，再判断，这样不断的增加步长，直到该位置为空，
                                                                                                                                          这样就避免了数据聚集在了一堆
                                                                                                                                          
                                            c.再哈希法:第一次执行fun散列函数后，如果有使用同一个下标的数据，比如22，再使用第二种fun散列函数给他找位置，还是冲突就第三种第四种函数，直到位置不冲突
                                         
                                2.链地址法:在散列表的数组对应的节点，放入一个链表进去(相当于创建了一个Map-List集合)例如12 22，先将12放入下标为2的位置，因为每个下标的位置都含有
                                                                                                                    链表,先将12放入链表的第一个位置，22在加入的时候放入链表的第二个位置，12的链表指针指向22，后面如果还要给下标2存储数据，就在22后挨个添加，然后用前一个数据指向新添加的数据